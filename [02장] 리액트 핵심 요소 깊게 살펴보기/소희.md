# [02장] 리액트 핵심 요소 깊게 살펴보기

# 2.1 JSX란?

- 자바스크립트 표준 코드가 아닌, 페이스북이 임의로 만든 새로운 문법
- 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환
- HTML 이나 XML을 자바스크립트 내부에 표현
- JSX 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성해두고, 트랜스 파일을 통해 자바스크립트(ECMAScript)가 이해할 수 있는 코드로 변경하는 것이 목표
- 즉, 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는데 도움을 주는 새로운 문법

## 2.1.1 JSX의 정의

### JSXElement

JSX 구성하는 기본 요소로, HTML의 요소(element)와 비슷한 역할을 한다.

- JSXOpeningElement - <JSXElement JSXAttributes(optional)>
- JSXElementName: JSXElement의 요소 이름으로 쓸 수 있는 것
  - JSXIdentifier: JSX 내부에서 사용할 수 있는 식별자 (자바스크립트 식별자와 동일하게 숫자 혹은 `$` , `_` 을 제외한 특수문자로 시작 불가능
  - JSXNamespacedNAme: `JSXIdentifier:JSXIdentifier` 의 조합. `:`을 통해 서로 다른 식별자를 이어 하나의 식별자로 취급 (두 개의 식별자만 이을 수 있음)
  - JSXMemberExpression: `JSXIdentifier.JSXIdentifier` 의 조합. `.` 을 통해 서로 다른 2개 이상의 식별자를 이어 하나의 식별자로 취급
- JSXClosingElement - </JSxElement> (책 오타 https://github.com/wikibook/react-deep-dive-example/issues/8)
- JSXSelfClosingElement - <JSXElement JSXAtrributes(optional) />
- JSXFragment - <>JSXChildren(optional)</>

> React에서는 HTML 태그명과 사용자가 만든 컴포넌트 태그명을 구분 짓기 위해, 사용자 컴포넌트는 대문자로 시작하여 만들어야 한다.

### JSXAttributes

JSXElement에 부여할 수 있는 속성이며, 필수값이 아니다.

- JSXSpreadAttributes

  - {…AssignmentExpression}: 객체뿐만 아니라, 조건문 표현식, 화살표 함수, 할당식 등 자바스크립트에서 AssignmentExpression으로 취급되는 모든 표현식이 존재한다.
  - 예시
    `dynamicProps가 AssignmentExpression을 포함하고 있으며 스프레드 연산자로 속성 부여

    ```jsx
    const otherProps = {
      className: "custom-class",
      style: { color: "blue" },
    };

    const MyComponent = () => {
      const dynamicProps = {
        id: "myId",
        ...otherProps, // 스프레드 연산자를 사용하여 otherProps의 속성을 전개
      };

      return <div {...dynamicProps}>Hello, World!</div>;
    };
    ```

- JSXAttribute

  - JSXAttributeName: 속성의 키 값. 키로는 JSXIdentifer 와 JSXNamespacedName 가
  - code

    ```jsx
    fucntion valid1() {
    	return <foo.bar foo:bar='baz'></foo.bar>

    ```

  - JSXAttributeValue: 속성의 키에 할당할 수 있는 값
  - `"` , `'` , `{AssignmentExpression}`, `JSXElement` , `JSXFragment`

### JSXChildren

JSXElemnt의 자식 값.

- JSXChild: JSXChildren을 이루는 기본 단위로, JSXChildren으ㄴ JSXChild를 0개 이상 가질 수 있다.

### JSXStrings

큰(및 작은)따옴표로 구성된 문자열 혹은 JSXText를 의미

`\\`로 시작하는 이스케이프 문자는 자바스크립트에서 특수문자를 처리할 때 사용되므로 몇 가지 제약사항(`\\` 를 표한하기 위해서 `\\\\` 로 이스케이프 해야함)이 있지만 HTML에서는 아무런 제약 없이 사용 가능

## 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?

`@babel/plugin-transform-react-jsx` 플러그인이 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환

# 2.2 가상 DOM과 리액트 파이버

## 2.2.1 DOM과 브라우저 렌더링 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)을 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4. 브라우저에 렌더링 엔진은 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 사용자 눈에 보이는 노드만 방문한다.(display:none 같은 요소는 방문 안함) => 트리 분석 과정을 빠르게 하기 위해서
6. 5번에서 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 CSS 스타일 정보를 해당 노드에 적용한다.
   - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계싼하는 과정(필연적으로 다음에 리페인팅 발생)
   - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습 그리는 과정

## 2.2.2 가상 DOM의 탄생 배경

### DOM 핸들링의 문제점

요즘 대다수 앱은 렌더링 이후 정보 보여주기 뿐만 아니라 사용자의 인터랙션을 통해 다양한 정보 노출한다.
이는 렌더링잉 완료된 이후에도 사용자의 인터랙션으로 웹페이지가 변경되는 상황 고려해야함을 의미한다.

- 특정 요소의 노출 여부가 변경되거나 사이즈가 변경되는 등 요소의 위치와 크기를 재계산하는 시나리오: 레이아웃 + 리페인팅
- 싱글 페이지 애플리케이션
  - 하나의 페이지에서 계속해서 요소의 위치를 재계산

### 가상 DOM

사용자 인터랙션에 따른 모든 DOM의 변경보다는 결과물을 제공하는 것이 브라우저 뿐만 아니라 개발자에게도 유용하다.
가상 DOM은 리액트(react-dom)가 관리하는 가상의 DOM으로, 웹페이지가 표시해야 할 DOM을 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때, 실제 브라우저의 DOM에 반영한다.

## 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버

### 리액트 파이버란?

리액트에서 관리하는 자바스크립트 객체다.
가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.
재조정(reconciliation)이란, 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)이다.
**리액트 파이버가 수행하는 일**

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않는 경우에는 폐기할 수 있다.

과거 리액트 조정 알고리즘은 스택 알고리즘이었으나, 사용자 인터랙션에 따른 동시 다발적인 이벤트와 애니메이션은 기존 렌더링 스택에서는 비효율적이었다.
리액트는 이 스택 조정자 대신 파이버라는 개념을 탄생시킨다.

**파이버의 구현**
파이버는 하나의 작업 단위로 구성된다.
리액트는 작업 단위를 하나씩 처리하고 `finishedWork()`라는 작업으로 마무리한다.
이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만들어낸다.
이러한 단계는 아래 두 단계로 나눌 수 있다.

1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 이 단계에서 앞서 언급한 파이버의 작업인, 우선수위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
2. 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업, `commitWork()`가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수 없다.
   리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만, 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용한다.

리액트의 핵심 원칙은 UI를 문자열, 숫자, 배열과 같은 값으로 관리한다. 이러한 UI 관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현한다.

**리액트 파이버 트리**
리액트 내부에는 현재 모습을 담은 파이버 트리와 작업 중인 상태를 나타내는 **workInProgress** 트리, 두 개가 존재한다.
리액트 파이버의 작업이 끝나면 포인터만 변경하여 **workInProgress** 트리를 현재 트리로 변경한다.(이러한 과정을 **더블 버퍼링**이라고 함)
리액트는 불완전한 트리를 보여주지 않기 위해 더블 버퍼링 기법을 쓰는데, 이러한 더블 버퍼링을 위해 트리가 두 개 존재하며, 더블 버퍼링은 커밋 단계에서 수행된다.

- 순서
  - 현재 UI 렌더링을 위해 존재하는 트리인 current를 기준으로 모든 작업 시작
  - 여기서 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 workInProgress 트리 빌드 시작
  - workInProgress 트리 빌드 작업이 끝나면, 다음 렌더링에 이 트리 사용
  - 이 workInProgress 트리가 UI에 최종적으로 렌더링되어 반영이 완료되면 current가 이 workInProgress로 변경된다.

## 2.2.4 파이버와 가상 DOM

리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이다.
이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다.
이러한 비동기 작업과 달리, 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로 이러한 작업을 가상에서, 즉 메모리상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

리액트와 리액트 네이티브의 렌더러가 서로 다르다 하더라도 내부적으로 파이버를 통해서 조정되는 과정은 동일하기 때문에 동일한 재조정자를 사용할 수 있게 된다.

## 2.2.5 정리

가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아닌, 값을 UI를 표현하는 것이다.
화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값을 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 리액트의 핵심이다.

# 2.3 클래스형 컴포넌트와 함수형 컴포넌트

## 2.3.1 클래스형 컴포넌트

### 클래스형 컴포넌트의 생명주기 메서드

- 마운트(mount): 컴포넌트가 마운팅(생성)되는 시점
- 업데이트(update): 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트(unmount): 컴포넌트가 더 이상 존재하지 않는 시점

**render()**
생명주기 메서드 중 하나로, 클래스형 컴포넌트의 유일한 필수 값이다.
이 함수는 컴포넌트가 UI를 렌더링하기 위해서 쓰이며, 마운트와 업데이트 과정에서 렌더링이 일어난다.
render()함수는 항상 순수해야 하며 부수 효과가 업성야 한다. 즉, 같은 입력값(props 또는 state)이 들어가면 항상 같은 결과물을 반환해야한다.
따라서 render() 내부에서 state를 직접 업데이트하는 setState를 호출해서는 안된다.

외에도 아래와 같은 메서드들을 활용하여 생명주기를 이룬다.
componentDidMount()
componentDidUpdate()
componentWillUnmount()
shouldComponentUpdate()

**클래스형 컴포넌트의 한계**

- 데이터의 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다
- 기능이 많아질수록 컴포넌트의 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다

## 2.3.2 함수형 컴포넌트

클래스형과 비교하였을 때,

1. 간결한 코드
2. render 내 필요한 함수 선언 시, this 바인딩 유의할 필요 없음
3. state가 각각의 원시값을 관리됨
4. return 내에서 this 사용업싱도 props와 state 접근 가능

## 2.3.3 함수형 컴포넌트 vs 클래스형 컴포넌트

### 생명주기 메서드의 부재

클래스형 컴포넌트의 생명주기 메서드가 함수형 컴포넌트에서 존재하지 않는다.생명주기 메서드는 `React.Component`에서 오는 것이기 때문이다.
함수형 컴포넌트는 `useEffect` 훅을 사용해 componentDidMount(), componentDidUpdate(), componentWillUnmount()를 비스하게 구현할 수 있으나, 똑같다는 의미는 아니다. useEffect는 컴포넌트의 state를 활용해 동기적으로 부수 효과를 메커니즘이다.

### 함수형 컴포넌트와 렌더링된 값

함수형 컴포넌트는 렌더링된 값을 고정하고, 클래스형 컴포넌트는 그렇지 못한다.

클래스형 컴포넌트는 props 값을 항상 this로부터 가져온다. 클래스형 컴포넌트의 props는 외부에서 변경되지 않는 이상 불변 값이지만, this가 가리키는 객체인 컴포넌트의 인스턴스 맴버는 변경 가능한 값이다.
따라서 render 메서드를 비롯한 리액트의 생명주기 메서드가 변경된 값을 읽을 수 있게 되어, 부모 컴포넌트가 props를 변경해 컴포넌트가 다시 렌더링됐다는 것은 this.rpops의 값이 변경된 것이다.

함수형 컴포넌트는 props를 인수로 받는다. 그리고 this와 다르게, props는 인수로 받기 때문에 컴포넌트는 그 값을 변경할 수 없고, 해당 값을 그대로 사용하게 된다.

- -> 함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링하지만, 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

# 2.4 렌더링은 어떻게 일어나는가?

- 브라우저의 렌더링: HTML과 CSS 소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정
- 리액트의 렌더링: 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정

## 2.4.1 리액트의 렌더링이란?

### 리액트의 렌더링

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정

## 2.4.2 리액트의 렌더링이 일어나는 이유

### 리액트 렌더링 발생하는 시나리오

1. 최초 렌더링: 사용자가 처음 애플리케이션 진입시 당연히 렌더링해야할 결과물을 브라우저에 제공하기 위해 최초 렌더링 수행
2. 리렌더링: 최초 렌더링 이후 발생하는 모든 렌더링

- 클래스형 컴포넌트의 setState 실행
- 클래스형 컴포넌트의 forceUpdate 실행
- 함수형 컴포넌트의 useState의 두 번째 배열 요소인 setter 실행
- 함수형 컴포넌트의 useReducer의 두 번째 배열 요소인 dispatch 실행
- props가 변경되는 경우
- 부모 컴포넌트가 렌더링될 경우 : 부모 컴포넌트가 리렌더링된다면 자식 컴포넌트도 무조건 리렌더링됨
- 컴포넌트의 key props가 변경되는 경우
  - 리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다.
    리액트에서 리렌더링이 발생하면 current 트리와 workInProgress 트리 사이에 변경 사항을 구별해야하는데, 이 두 트리 사이에서 같은 컴포넌트인지 구별하는 값이 key이다.
    이러한 변경 사항 구별 작업은 리렌더링이 필요한 컴포넌트를 최소해하므로 key를 통해 이러한 컴포넌트 구별 가능하다.
    만약 key가 없다면 파이버 내부의 sibling 인덱스만을 기준으로 판단하게 된다.

## 2.4.3 리액트의 렌더링 프로세스

1. 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
2. 컴포넌트를 찾게되면 클래스의 경우 render 함수 실행, 함수형의 경우 해당 컴포넌트 자체를 호출하여 결과물을 저장한다.
3. 이 결과물들은 자바스크립트로 컴파일되면서 Reat.createElement를 호출하는 구문으로 변환된다.

이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 수집한다.
이렇게 계산하는 과정을 리액트의 재조정(Reconciliation)이라고 한다.
재조정 과정이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보인다.

## 2.4.4 렌더와 커밋

앞서 정리한 리액트의 렌더링은 렌더 단계와 커밋 단계, 총 두 단계로 분리되어 실행된다.

### 렌더 단계

렌더링 프로세스에서 컴포넌트를 실행해(render() 또는 return), 이 결과와 이전 가상 DOM을 비교하는 과정으로 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다.
type, props, key 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해둔다.

### 커밋 단계

렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정으로, 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

> 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.
> 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 커밋 단계는 생략될 수 있다.
> 즉, 리액트의 렌더링은 가시적인 변경이 일어나지 않아도 발생할 수 있다.

# 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

## 2.5.1 주장1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 어디까지나 비용이 드는 작업이므로 최적화에 대한 비용을 지불 할 때는 항상 신중해야 한다는 주장이다.

1. 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업과 2. 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두 가지 비용이 있다.

그러므로, 섣부른 최적화(premature memoization)는 항상 경계해야 한다.

## 2.5.2 주장2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자

만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 때가 있다.

memo를 썼을 때 지불해야하는 비용

- props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용

어차피 리액트의 기본적인 알고리즘 때문에, 이전 렌더링 결과를 다음 레넏링과 구별하기 위해 저장해 둬야 한다. 따라서, 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐이다.
그러나, props가 크고 복잡해진다면 비용 또한 커질 수 있다.

memo를 하지 않았을 때 발생할 수 있는 문제

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두 가지 모두가 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

# [추가 조사] React Fiber

> 목표: React Fiber를 통해 React의 효율적인 렌더링 구조를 이해한다.

## 1. React Fiber 이전

- 전통적인 리액트에서는 **한 번에 하나의 작업만을 처리하며, 그 작업이 끝날 때까지 다른 작업을 중단하게 되는 동기식 렌더링**으로 동작하였다. 이 방식은 간단하고 예측 가능하지만, 긴 작업이 실행되는 동안에는 사용자 입력이나 애니메이션 등이 블로킹되어 버리는 단점이 있었다.

## **2. React Fiber란 무엇인가?**

- Fiber는 React의 내부 알고리즘으로, 더 효율적인 UI 렌더링을 가능하게 하는 기술로 위와 같은 문제를 해결하게 되었다. 이를 통해 앱의 성능을 향상시키고 사용자 경험을 개선할 수 있다.

- 구조: 컴포넌트 + 컴포넌트 input + 컴포넌트 output 에 대한 정보를 포함한 자바스크립트 객체
  - 컴포넌트 input(입력): 컴포넌트에 대한 입력 데이터를. 주로 컴포넌트의 속성(props) 및 상태(state)와 관련이 있다. Fiber는 컴포넌트가 렌더링될 때 이 입력 데이터를 참조하고 사용한다.
  - 컴포넌트 output(출력): 컴포넌트가 렌더링되고 나면, Fiber는 해당 컴포넌트의 출력 결과를 나타낸다. 출력은 일반적으로 Virtual DOM의 변경 내용을 포함하며, React는 이를 사용하여 실제 DOM을 업데이트한다.

## **3. 왜 React Fiber가 필요한가?**

- React Fiber의 주요 목표 중 하나는 **애니메이션, 레이아웃 및 제스처와 같은 작업들을 더 부드럽게 처리할 수 있도록 하는 것**이다. **비동기적**인 방식으로 작동하여 작업을 세분화하고, **중요한 업데이트를 우선**시하고, **덜 중요한 업데이트는 나중에 처리**함으로써 **사용자 경험 향상 및 성능 최적화**를 할 수 있게 되었다.
  - 비동기 렌더링
  - 우선 순위 기반 스케줄링
    - 사용자 입력이나 애니메이션 등의 작업은 높은 우선 순위
    - 데이터를 불러오거나 대량의 상태 업데이트 등의 작업은 낮은 우선 순위

## **4. React Fiber의 주요 개념**

### 4.1 재조정(Reconciliation)과 렌더링(Rendering)의 분리

React의 렌더링 프로세스는 크게 reconciliation과 rendering으로 나뉜다. Reconciliation은 가상 DOM 트리를 사용하여 이전 상태와 현재 상태 간의 차이를 계산하는 과정이다.

Fiber는 이 reconciliation 과정을 더 효율적으로 만들기 위한 것으로, 이전에는 한 번에 처리되던 업데이트를 작은 단위로 분할하여 우선순위를 부여하고 중단된 작업을 재개할 수 있도록 하는 방식을 도입한 것이다.

Rendering은 이 변경사항을 렌더러를 통해 특정 환경(ex. DOM)에 반영하는 작업이다.

이 분리로 인해 React DOM과 React Native가 동일한 Reconciler를 공유하면서도 자체 렌더러를 사용할 수 있다. Fiber는 Reconciliation을 주로 다루지만, 각 렌더러는 이를 기반으로 자체적인 업데이트 및 렌더링 로직을 구현하여 특정 환경(DOM, iOS, Android 플랫폼 등)에 맞게 동작하고 이것이 React가 다양한 환경에 적용할 수 있도록 하는 핵심적인 특성이다.

### 4.2 React Fiber의 주요 개념

- **Fiber는 작업 단위**를 의미하며, 각각의 Fiber는 작업을 수행하는데 필요한 정보를 포함한다.
- Fiber는 두 가지 단계, 즉 **렌더 단계와 커밋 단계**로 나누어진다.
- **렌더 단계는 가상 DOM 트리를 구성하는 단계**이며, 이 단계에서는 중단하거나 다시 시작할 수 있다.
- **커밋 단계는 실제 DOM에 변경 사항을 적용하는 단계**로, 이 단계는 중단할 수 없다.

### 4.3 React render 단계와 commit 단계

** render 단계 (Reconciliation)**
Reconciliation (재조정): 렌더 단계에서는 Fiber가 Virtual DOM을 통해 Reconciliation을 수행한다. Reconciliation은 현재 상태와 이전 상태의 차이를 계산하고, 업데이트가 필요한 부분을 결정한다. 이때 기준이 되는 것은 Virtual DOM이며, 컴포넌트의 상태나 속성 변경 등이 여기서 처리된다.

**commit 단계 (Rendering)**
Rendering (렌더링): 커밋 단계에서는 Reconciliation 단계에서 계산된 변경 사항을 실제 DOM에 반영한다. 이때 렌더러(Renderer)가 개입한다. 렌더러는 React의 특정 환경에 따라 DOM, Native (React Native), 또는 다른 환경에 변경 사항을 커밋하는 역할을 한다.

따라서, Reconciliation은 렌더 단계에서 일어나며, 커밋 단계에서는 렌더러가 Reconciliation에서 계산된 변경 사항을 실제 화면에 반영한다.

이 구조는 React Fiber가 더 효율적인 업데이트를 가능케 하는 중요한 특성 중 하나이다.

> **리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.**
> 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경 사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 커밋 단계는 생략될 수 있다.
> 즉, 리액트의 렌더링은 가시적인 변경이 일어나지 않아도 발생할 수 있다.

## **5. React Fiber의 장점**

- **비동기 렌더링**: Fiber는 작업을 미세 조정하여 중요한 업데이트를 먼저 처리하고, 그 외의 업데이트는 나중에 처리하는 비동기 렌더링을 가능하게 한다.
- **효율적인 계산**: Fiber는 작업을 여러 개의 작은 단위로 나누어, 더 효유적으로 계산할 수 있게 한다.

## 6. 예시 코드

```jsx
import React, { useState } from "react";

function App() {
  const [clicked, setClicked] = useState(false);

  const handleClick = () => {
    setClicked(true);
  };

  const items = Array(10000)
    .fill()
    .map((_, i) => <li key={i}>Item {i}</li>);

  return (
    <div>
      <button onClick={handleClick}>Click me</button>
      <ul>{items}</ul>
    </div>
  );
}
```

### 설명

10000개의 항목을 렌더링하고 있는 코드가 함수 블럭 안에 있다.

기존의 리액트에서는 이런 경우, 모든 항목의 렌더링이 완전히 완료될 때까지 ‘Click me’ 버튼이 동작하지 않는다.

리액트가 렌더링 작업을 한 번에 처리하고, 그 작업이 완료될 때까지 다른 작업을 중단하기 때문이다.

리액트 파이버는 작업을 더 작은 단위로 나누어, 클릭 이벤트(우선 순위가 높음)가 발생했을 때, 1000개의 항목을 렌더링하는 작업을 잠시 중단하고 나중에 처리한다.

## 정리

React Fiber는 비동기적이고 효율적인 렌더링을 위한 내부 구조를 제공하며, Reconciliation은 어떤 부분이 변경되었는지를 계산하고, 렌더링은 변경된 부분을 실제로 화면에 업데이트(commit)하는 역할을 한다.
이를 통해 React는 더 나은 성능과 사용자 경험을 제공할 수 있다.
