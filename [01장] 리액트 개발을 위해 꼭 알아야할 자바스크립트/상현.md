# 상현

## 객체

객체 비교 시 `Object.is`를 사용하는 것이 부합

```tsx
Number.NaN === NaN;
Object.is(Number.NaN, NaN); // true
```

위를 토대로 react는 `objectis`함수를 만들어서 사용하고 `shallowEqual` 함수를 만들어서 사용.
리액트 비교는, `Object.is`를 통하여 먼저 비교를 하고, 수행하지 못하는 것은 객체간의 얕은 비교를 한번더 실행 === 첫 번째 깊이 값만 비교

```tsx
Object.is({ hello: "world" }, { hello: "world" }); // false
shallowEqual({ hello: "world" }, { hello: "world" }); // true
shallowEqual({ hello: "world" }, { hello: "world, hi" }); // false
```

**왜 객체의 얕은 비교까지 구현? props를 기준으로 렌더링을 수행. 깊은 비교를 하면 재귀적 처리로 인하여 성능에 악영향**
따라서 props를 통해서 1depth 이상의 것을 넣어주면 최적화를 진행하지 못하는 모습을 보여줌.

```tsx
<Component counter={100} />
<DeeperComponent counter={{ counter: 100 }} />
```

## 함수

표현식 vs 선언식

- 차이점: 호이스팅

함수 작성 시 주의사항

- 부수효과 최대한 억제: 리액트 관점에서는 useEffect의 사용을 최소한으로 한정
- 함수 코드 길이 생각: 함수가 클 수록 냄새가 나다(eslint의 max-lines-per-function 옵션이 존재)
- 누구든 이해할 수 있는 이름

## 클래스

**propto**는 가급적 사용 자제. 왜냐하면 과거 호환성 유지를 위해 남겨 둘 뿐…

정적 메서드 vs 인스턴스 메서드

- (P82)정적 메서드는 인스턴스를 사용하지 않아도 되기에 전역에서 사용하는 유틸함수로 많이 활용

## 클로저

함수 컴포넌트에 대한 이해는 클로저와 연결

스코프

- 전역 스코프: global, window
- 함수 스코프: {} 내부에 스코프.

클로저가 무조건 좋을까?

- NO. 클로저는 내부의 정보를 은닉하고 값을 사용할 수 있지만, 그 상황을 기억해야하기에 메모리를 잡는다. 따라서 상황에 따라 사용.

## 이벤트 루프와 비동기 통신의 이해

멀티 쓰레드vs 싱글 쓰레드

- 싱글 쓰레드는 직렬화된 작업을 하나씩 처리, 멀티는 메모리를 공유하면서 다중 처리

자바스크립트는 왜 싱글 스레드일까?

- 브라우저에 간단한 스크립트를 지원할 목적으로 탄생
- 멀티일 경우 메모리 공유로 인하여 다중 처리될경우 DOM 표시에 문제 야기 가능성

이벤트 루프

- 자바스크립트 런타임 외부에서 자바스크립트 비동기 실행을 돕기 위해 만들어진 장치
- “코드 실행”과 “호출 스택 비어있는 지 확인”은 모두 단일 쓰레드에서 발행. 동시 X
- 호출 스택: 호출해야할 작업들을 stack 자료구조로 모아놓은 곳
- 테스크 큐: 실행해야 할 테스크의 집합.
  - 자료구조 queue가 아니라 set형태. WHY? 선택된 큐 중에서 실행 가능한 가장 오랜 테스크를 가져와야 함
  - 이 작업들은 자바스크립트의 메인 쓰레드가 아닌 별도의 쓰레드에서 실행(web api 또는 node.js)
  - 테스크 큐 & 마이크로 테스크 큐
    - 마이크로 테스크가 우선순위를 가지고 있으며 전부 실행이 완료되기 이전까지 테스크는 중지
    - 렌더링 시점: 각 마이크로 테스크 큐 작업이 끝날 때 한 번씩 렌더링 기회 획득. 반대로 테스트 큐는 실행 시 마다 렌더링 획득???

## 리액트에서 자주 사용하는 자바스크립트 문법

배열 분해 할당

- useState가 배열을 반환하고 있는데, WHY? (추측) 객체 분해 할당과 달리 배열 분해 할당하는 곳에서 자유롭게 이름 선언 가능

객체 분해 할당

- 분해할당이 ECMA 2018에 나왔기에 이전과 호환성을 맞추기 위해 컴파일이 되면 용량이 커진다

전개 구문(…)

- 객체의 덮어씌우기 및 객체의 babel 결과는 용량을 잡아 먹음

## 새롭게 알게 된 사항

- 자바스크립트의 과거를 봤을 때 왜 싱글 스레드를 채택했는지 추측을 해볼 수 있게 설명
  - 자바스크립트 생성 당시, 멀티 쓰레드의 개념이 신규 생성. 멀티 쓰레드는 하나의 프로세스 안에서 메모리를 공유하며 다중 처리를 실행.
    - 멀티로 인하여 DOM의 commit이 다중적으로 처리되어 다른 쓰레드 일 처리에 영향을 줄수 있다는 점
  - 자바스크립트는 브라우저의 단순한 보조 역할로만 생각.
  - 그러면 멀티 쓰레드를 고려하고 있는가? [(2007년)브렌든 아이크 왈: 절대 없음](https://brendaneich.com/2007/02/threads-suck/)
- 추측일 수는 있다고 하지만 useState가 객체 분해할당과 달리 배열 분해 할당을 쓰는 이유를 생각 ⇒ 배열 분해 할당 시의 명명이 자유로운 점을 처음 알게 됨
- lint로 함수의 줄을 줄일 수 있음을 확인 ⇒ 기존 코드들의 길이가 길어서 가독성이 좋다고 생각하지 않지만, 나 또한 가끔 함수의 길이가 길어질 때가 있으므로 고려 가능한 사항
