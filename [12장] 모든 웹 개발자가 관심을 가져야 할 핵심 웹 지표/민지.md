# 민지

## 캐시

### 캐시란?

데이터나 값을 미리 복사해 놓은 임시 저장소

### 언제 사용하나요?

- 원본 데이터에 **접근하는 시간**이 오래 걸리는 경우
- 값을 다시 **계산하는 시간**을 절약하고 싶은 경우

### 왜 사용하나요?

- 캐시에 데이터를 **미리 복사**해 놓으면 **계산이나 접근 시간 없이** 더 **빠른 속도**로 데이터에 접근할 수 있다.
- 즉, 속도는 높이고, 비용은 절감할 수 있다.

- 캐시는 컴퓨터 전반에 걸쳐 사용된다.

- **브라우저 캐시**
  - 클라이언트에 저장되는 캐시로, 각 유저를 위해 개인화된 콘텐츠를 저장하고 재사용
  - 로컬 캐시, private 캐시, HTTP 캐시라고도 불린다.
- **공유된 캐시**
  - 클라이언트와 origin 서버 사이에 존재하는 캐시로, Proxy나 CDN을 말한다.
  - 하나의 응답을 저장하고 여러 사용자에게 재사용
  - 따라서 공유된 캐시에는 개인화된 콘텐츠를 저장하면 안 된다.

## 브라우저 캐시

- 브라우저는 서버에 요청을 보내기 전 먼저 브라우저 캐시에 접근해 캐싱된 데이터가 있는지 확인하고 있으면 해당 데이터 사용

### 문제 1) 서버에 있는 데이터가 업데이트 된다면?

- 브라우저가 캐시 데이터를 언제까지 사용해야할지 판단할 수 있도록 서버는 리소스 응답 시 **해당 리소스를 캐싱할 수 있는 시간**을 명시해서 보낸다.
- 이 내용은 HTTP Cache-Control 헤더에 **max-age** 값을 명시
  - max-age는 리소스 캐싱 가능한 최대 시간(초)
  - 예를 들어, max-age=60은 60초 동안 캐시되어 재활용될 수 있음을 나타낸다.

### 문제 2) 캐시가 만료됐지만 리소스가 같다면?

- 변경되지 않은 리소스를 서버에서 다운로드 하는 작업은 **비효율적**이다. 이미 캐시에 있는 동일한 정보를 다운로드할 이유가 없기 때문.
- **ETag**를 활용: ETag는 리소스 내용을 바탕으로 만든 해시값
  1. 서버는 리소스 조회 요청이 오면 **ETag HTTP 헤더**를 사용해 **유효성 검사 토큰**을 전달
  2. 브라우저 캐시 내 **리소스가 만료되면** ETag를 서버에 보내 해당 리소스에 **변경 사항이 있는지 확인**한다.
     3-1. **ETag 값을 비교해 동일하다면** 변경사항이 없다는 뜻이므로 헤더에 `304 Not Modified` 응답과 **Etag** 값을 보내고, 브라우저는 **캐시 데이터 그대로 사용**
     3-2. **ETag 값이 다르다면** `200 OK`와 **업데이트된 리소스와 ETag**를 내려준다. → 업데이트 된 리소스 사용
- ETag를 사용하면 변경되지 않은 리소스를 서버에서 다운로드하지 않아 **효율적인 리소스 업데이트 검사**가 가능

### 문제 3) 리소스의 만료 기한이 긴데 리소스가 업데이트된다면?

- 사용자가 브라우저 캐시를 지우지 않는 한 캐시된 화면을 보게 된다.
- **리소스 URL을 변경**하는 방식으로 해결: cache-busting 패턴
  - 파일의 버전 번호나 날짜, 해시값 등을 파일 이름에 포함하는 방식으로 수행
  - 브라우저는 리소스 URL이 변경되면 새로운 데이터로 인식
- 따라서 보통 정적 파일(JavaScript, CSS)은 max-age 값은 길게 두고, 파일의 버전 번호를 명시해 수정 시마다 파일을 업데이트한다. 이렇게 하면 빌드 시마다 새로운 파일로 인식한다.
  ```jsx
  a.com/style.css?Date.now()
  ```
- 정적 파일 자체가 변경되지 않기 때문에 사용자가 브라우저를 리로드하더라도 정적 파일을 검증하기 위해 origin 서버에 요청을 보낼 필요가 없다.
- cache-busting 패턴을 사용하고, max-age를 길게 잡으면 `immutable`을 추가해 재검증을 막을 수 있다.
