# 상현
## 12.1 웹사이트와 성능

사용자가 기대하는 사항(”방문자들은 그다지 인내심이 많지 않다”)

- 방문한 목적을 손쉽게 달성
- 목적 달성까지의 시간 짧음
- 개인정보 보안

## 12.2 핵심 웹 지표란?(Core Web Vitals)

3개의 핵심 지표

- Larget Contentful Paint(LCP, 최대 콘텐츠풀 페인트)
- First Input Delay(FID, 최초 입력 지연)
- Cumulative Layout Shift(CLS: 누적 레이아웃 이동

## 12.3 최대 콘텐츠풀 페인트(LCP)

> 정의: 페이지가 처음으로 로드를 시작한 지점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간
> 

큰 이미지란?

- <img>
- <svg> 내부의 <image>
- poster 속성을 사용하는 <video>
- url()을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레밸 요소
    - 블록 레벨 요소에는 <p>, <div> 포함

**뷰표트를 기준으로 하고 있기에 LCP에 영향을 미치는 부분은 오직 뷰포트 영역**

- DOMContentLoaded는 HTML 문서를 완전히 불러오고 파싱했을 때 이벤트가 호출되는 데, 스타일시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다”는 제한이 존재. 따라서, 호출되어도 아직도 화면을 그리는 중일 수도 있음
- 따라서, 보이는 영역을 기준으로 측정하게 됨

점수: 완료시간이 2.5초 이내면 좋음 , 보통은 4초, 그 이상은 나쁨

개선방안

- 이미지보다는 텍스트
- 이미지관련해서는
    - <img> 태그는 프리로드 스캐너를 통해서 HTML 파싱이 완료되지 않더라고 병렬적 처리 가능
    - <video>의 poster는 사용자가 요소를 재생하거나 탐색하기 전까지 노출되는 요소. 이 또한, 프리로드 스캐너에 의해 조기 발견되어 병렬 처리
    - css에 있는 리소스는 항상 느리기에 고려
    - image 무손실 압축 고려
    - loading=lazy는 주의. 중요하지 않음으로 표시하고 필요할 때 로드하기에, LCP의 이미지에는 사용하지 않는 것이 좋음
    - fadein과 같은 각종 애니메이션 또한 시간 증가에 기여
    - LCP에 잡히는 영역이 클라이언트에서 호출 또는 빌드되면 느려지기에 서버에서 미리 빌드된 채로 오는 것이 좋음
    - LCP 리소는 직접 호스팅이 좋음. 중요한 이미지는 같은 도메인에서 직접 호스팅하는 것이 좋음

## 12.4 최초 입력 지연(FID)

> 사용자가 페이지와 처음 상호 작용할 때부터 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작히기까지의 시간
> 

늦어지는 이유는 브라우저의 메인 스레드가 다른 작업을 처리하고 있기 때문.

- Response: 사용자의 입력에 대한 반응 속도 50ms 미만으로 이벤트 처리
- Animation: 각 프레임으로 10ms 이하
- Idle: 유후 시간을 극대화해 페이지가 50ms이내에 응답하게 설정
- Load: 5초 이내에 콘텐츠를 전라하고 인터렉션을 준비할 것

이벤트 핸들러의 실행 시간을 측정하고 싶다면 “Event Timing API” 사용하는 것이 좋음

점수: 100ms 이내면 좋음, 300ms 이내면 보통, 그 이후는 나쁨

개선방안

- 실행에 오래 걸리는 긴 작업 분리:
    - 꼭 웹 페이지에서 해야 하는 작업인지 생각하여 필요하다면 의도적으로 CPU 또는 네트워크를 낮춰서 테스트 하여 고려
    - 긴 작업을 여러 개로 분리 하여 부담 줄이기
- 자바스크립트 코드 최소화
    - 개발자 도구 커버리지 클릭하여 기록 후 사용되지 않는 코드 확인  가능
    - polyfill 환경 체크
- 타사 자바스크립트 코드 실행 지연
    - Google Analytics나 Firebase와 같이 제3자의 코드에는 async와 defer를 이용해서 지연 불러오기가 좋음. 가능하면 async, 더 가능하다면 defer로 지연.

## 12.5 누적 레이아웃 이동(CLS)

> 콘텐츠의 위치가 밀리거나 상호작용하려고 했던 요소의 위치가 바뀌게 되는 현상
> 

점수 계산 방법

- 영향분율: 요소 높이 + 레이아웃 이동 점수 / 100 = (10 + 10) / 100 = 0.2점
- 거리분율: 레이아웃 이동이 뷰포트 대비 얼마나 이동했는지 의미
    - 10만큼 내려갔고 전체 뷰표트가 100이라면 0.1점
- 최종점수 = 영향분율 * 거리분율 = 0.2 * 0.1 = 0.02

점수: 0.1 이하 좋음, 0.25 이하 보통, 그 외는 개선 필요

개선방안

- 삽입이 예상되는 요소를 위한 추가적인 공간 확보
    - useEffect를 최소화하거나 useLayoutEffect고려(최소한으로)
    - 스켈레톤과 같은 미리 공간 확보
    - 서버 사이드 렌더링을 통해 HTML정보를 미리 확보
- 폰트 로딩 최적화
    - 폰트 문제 발생 상황
        - FOUT(flash of unstyled text): 기본 본트로 보이다가 뒤늦게 적용되는 현상
        - FOIT(flash of invisible text): 폰트 자체가 로딩이 되어서 뒤늦게 나타나는 현상
    - link의 preload사용
- 적절한 이미지 크기 설정
    - width, height 지정하고, 브라우저의 aspect-ratio기능을 활용하여 자동 맞춤 설정
    - 뷰포트 너비에 따라 다른 이미지를 제공하는 경우 srcset속성 사용하여, 여러개의 이미지를 미리 준비해둔 다음 브라우저가 상황에 따라 사용하도록 설정
        
        ```tsx
        <img 
        	width="100"
        	height="100"
        	src="image-100.jpg"
        	srcset="image-200.jpg 200vw, image-300.jpg 300vw"
        />
        ```
        

### 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

Time To First Byte(TTFB)

- 브라우저가 첫 번째 바이트를 수신하는데 걸리는 시간
- 600ms이상 시, 개선 필요
- 서버 사이드 렌더링 시 주의 깊게 관찰
    - 서버에서 생성되는 시간을 최대한 빨리. 즉 최적화
    - 국적과 가까운 저장소 사용

First Contentful Paint(FCP)

- 페이지 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때가지의 시간
- 1.8초 이내면 좋음, 3.0초는 보통, 이후는 개선 필요
- 개선방법
    - TTFB를 개선해서 뭐라도 빨리 받아오게 단축
    - 렌더링을 가로막는 리소스 최소화. 즉 JS 또는 CSS를 비동기적으로 처리
    - Above the Fold 최적화: 스크롤하지도 않아도 보이는 영역을 의미하여 이 부분은 결국 뷰포트
    - 페이지 리다이렉트 최소화
    - DOM 크기 최소화: 복잡하면 오래 걸리기에 1500개 미만, 깊이는 32단계 정도만 가지며 부모 노드는 자식 노드를 60개 정도만 가지기